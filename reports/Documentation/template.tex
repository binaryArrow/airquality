\documentclass[]{article}
\usepackage[german]{babel}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage[backend=bibtex, natbib=true]{biblatex}
\usepackage{listings}
\usepackage{tikz}

\lstset{%
	basicstyle=\ttfamily\scriptsize,        % Code font, Examples: \footnotesize, \ttfamily
	keywordstyle=\color{blue!80!black},     % Keywords font ('*' = uppercase)
	commentstyle=\color{gray},              % Comments font
	numbers=left,                           % Line nums position
	numberstyle=\tiny,                      % Line-numbers fonts
	stepnumber=1,                           % Step between two line-numbers
	numbersep=5pt,                          % How far are line-numbers from code
	backgroundcolor=\color{gray!10!white},  % Choose background color
	frame=none,                             % A frame around the code
	tabsize=2,                              % Default tab size
	captionpos=b,                           % Caption-position = bottom
	breaklines=true,                        % Automatic line breaking?
	breakatwhitespace=false,                % Automatic breaks only at whitespace?
	showspaces=false,                       % Dont make spaces visible
	showstringspaces=false                  %
	showtabs=false,                         % Dont make tabls visible
	columns=flexible,                       % Column format
	morekeywords={},                        % Specific keywords
	stringstyle=\color{green!50!black},%
}%

\bibliography{bibliography}
%opening
%Here you can enter your names and titleof your report
\title{Dokumentation - Luftqualität in Innenräumen - Gruppe 1}
\author{Friedrich Just 1326699 \\ Stipe Knez 1269206 \\ Lucas Merkert 1326709 \\ Achim Glaesmann 1309221 \\ Max-Rene Konieczka 1211092 \\ Can Cihan Nazlier 1179244}

\begin{document}

	\begin{titlepage}
		\maketitle
		\thispagestyle{empty}
	\end{titlepage}
	\tableofcontents
	\setcounter{page}{1}
	\newpage
	
	
	\section{Projektthema}
	Die durch Covid-19 verursachte Pandemie prägte die letzten 2 Jahre der gesamten Welt. Insgesamt forderte die Krankheit etwa 5,18 Millionen Menschenleben. Dennoch ist das Thema aktueller denn je. Europaweit steigen die Infektionszahlen auf nie dagewesene Werte, während die im Sommer verabreichten Impfungen langsam an Effektivität verlieren. Ein Hauptrisiko zur Infektion besteht dabei in Innenräumen. Unser Auftrag besteht nun darin, ein System zu entwickeln welches in der Lage ist, das Infektionsrisiko einzelner Räume eines Gebäudes einzuschätzen und so einen Richtwert für den Anwender darstellt, wie er sein Verhalten diesem Wert anpassen kann. Realisiert werden soll dieses System über die Verwendung verschiedener Sensoren zur Erfassung mit dem Infektionsrisiko direkt verknüpfter physikalischer Größen. Die zur Ansteckung, vermutlich, wichtigen Aerosole, können dabei nur bedingt durch Masken zurückgehalten werden, es macht also Sinn abzuschätzen inwieweit die Luft eines Raumes durch Aerosole belastet ist. Da die direkte Messung von Aerosolen zeitaufwendig und schwer umsetzbar ist, konzentrieren wir uns hierbei auf Werte, die einen direkten Rückschluss auf die Ausatemmenge der Personen im Raum ermöglichen, mit der Annahme, dass die Aerosolkonzentration dabei direkt abhängig zur Ausatemmenge ist.\newline
	Um dies zu erreichen, bedienen wir uns folgender Sensoren: Dem CCS811 von Adafruit, dem SCD41 und dem SHT21 von Sensirion. Der CCS881 ist ein energieeffizienter digitaler Gassensor, welcher über die Verwendung eines Metalloxidsensors ein breites Spektrum an flüchtigen organischen Verbindungen messen kann. Diese gibt der Sensor als CO2-Äquivalente an. Der CO2-Äquivalenzbereich geht hierbei von 400ppm bis 8192ppm. Eine Kompensation für Abweichungen durch Temperatur und Luftfeuchtigkeit ist dabei über einen externen Feuchtigkeits- und Temperatursensor möglich. Dies ermöglicht in Verbindung mit einem Mikrokontroller die Überwachung der Luftqualität. Der Sensor enthält dabei eine I²C-Schnittstelle sowie einen Analog-Digital-Converter (ADC).
	Der SHT21 ermöglicht die Messung der relativen Luftfeuchtigkeit so wie der Temperatur mit einer Genauigkeit von ±2\% relativer Luftfeuchtigkeit so wie ±0.3° Celsius bezüglich der Temperatur.\newline
	Beim SCD41 Sensor handelt es sich um einen miniaturisierten CO2-Sensor basierend auf dem photoakustischem Sensorprinzip. Dabei wird über einen integrierten SHT41 Feuchtigkeits- und Temperatursensor eine chipinterne Signalkompensierung ermöglicht. Die Genauigkeit des SCD41 befindet dabei im Bereich von 400 ppm – 5’000 ppm ± (40 ppm + 5\% des abgelesenen Wertes). Beide Sensoren von Sensirion können über die I²C-Schnittstelle angesprochen werden. Genauere Informationen zu den Sensoren sind im Unterkapitel Sensoren vermerkt.\newline
	Die so ermittelten Daten sollen anschließend in eine graphische Darstellung in Form einer Ampelindikation überführt werden, um dem Anwender eine direkte Bewertung der Gefahrenlage zu ermöglichen. Die Kommunikation zwischen Mikrocontroller und Sensoren soll dabei via I²C-Schnittstelle erfolgen, die Kommunikation zwischen den einzelnen Mikrokontrollern auf Basis des ZigBee-Protokolls. Um dies zu ermöglichen wurde entschieden, einen Mikrokontroller auf Basis des Atmega256rfr2-Chips zu verwenden, welcher die Verwendung beider Übertragungsprotokolle ermöglicht, so wie eine serielle Kommunikation über eine UART-Bridge. Die ermittelten Daten werden wie erwähnt seriell an eine von uns entwickelte Applikation auf einem leistungsfähigeren Endgerät übermittelt, welches die Daten auswertet und in ein graphisches Modell des zu beschreibenden Zimmers einbettet. Das Frontend sowie das Backend der Applikation soll dabei mittels TypeScript und dem Framework Vue realisiert werden. Die Applikation soll es dem Anwender grundsätzlich ermöglichen eigene Grundrisse zu zeichnen, Räume zu definieren und Sensoren in diesen zu platzieren. Die ermittelten Werte der Sensoren sollen dabei einmal innerhalb von Graphen zeitlich dargestellt werden sowie die über einen eigens zu entwickelnden Algorithmus errechnete Gefahrenlage mittels eines Ampelsystems einmal innerhalb der Anwendung als auch über eine am jeweiligen Funkmodul angebrachte LED dargestellt werden. 
	
	\section{Projektorganization}
	\subsection{Kommunikation}
	Um unsere Fortschritte abzustimmen und Meetings zu planen, wurden zu Beginn des Projekts eine WhatsApp Gruppe sowie ein Discord Server eingerichtet, damit jeder Gruppenteilnehmer auf dem neuesten Stand sein konnte. Zur Überprüfung, wer welche Aufgabe übernommen hat, ist entschieden worden den Aufgaben-Verwaltungs-Onlinedienst Trello zu verwenden. Hierdurch können innerhalb von Teams “Karten” zugewiesen werden, die dann Schritt nach dem Schritt bearbeitet werden. Wenn eine Aufgabe erledigt wurde, musste dies von einem anderen Gruppenmitglied getestet und bestätigt werden.\newline Innerhalb der Gruppe wurde sich vorgenommen, mindestens einmal pro Woche ein Meeting abzuhalten, um die Weiterentwicklung oder aufgetretene Probleme zu besprechen.
	
	\subsection{Tools und Frameworks}
	Als IDE wurde schlussendlich nur Webstorm benutzt, da die gesamte Applikation in Javascript und Typescript implementiert wurde. Es wurde auch ursprünglich geplant influxDB zu verwenden um die Sensordaten abspeichern zu können, doch dies hätte bei der Erstellung einer Installationsdatei für den Anwender zu Komplikationen führen können, daher wurde entschieden auf SQLite umzusteigen. Um das Senden von Mockdaten zu simulieren, wurde für kurze Zeit das Programm Virtual Serial Port verwendet um virtuelle COM-Ports zu erstellen um die Mockdaten übertragen zu können.\newline
	Die Applikation verwendet auf der Seite des Backends das Express.js Framework von Node.js, welches viele Funktionen zur Erstellung von Webanwendungen anbietet. Auf der Frontend-Ebene wird das Vue.js Framework benutzt, mit welchem sich Komponenten, aus einer Kombination von HTML, CSS und Javascript, erstellen lassen. 
	
	
	\section{Aufgabenaufteilung} %kurze aufgabenteilung
	Zu Beginn des Projektes wurde entschieden die Aufgaben in zwei Teile aufzuteilen, einerseits in einen Sensorteil und andererseits in einen Applikationsteil. Es wurde festgelegt, dass Herr Merkert, Herr Just und Herr Glaesmann für die Einrichtung und Programmierung der Sensoren zuständig sind, während Herr Knez, Herr Nazlier und Herr Konieczka für die Einrichtung eines Servers und die Entwicklung der Applikation zuständig sind. 
		\subsection{Friedrich Just}
		\subsection{Stipe Knez}
			Herr Knez hat sich in die Programmiersprache Python eingearbeitet um die Mockdaten erstellen zu können. Darüber hinaus hat er bei der Einrichtung des Backends geholfen sowie die Verbindung zwischen ZigBee-Modul und Backend über die COM-Port Schnittstelle hergestellt. Zuletzt hat er ebenfalls am Dashboard mitgearbeitet. 
		\subsection{Lucas Merkert}
			Aufgabe von Herr Merkert war die Programmierung des CCS811 Sensors, verschiedene administrative Aufgaben wie das organisieren von Meetings und Abgabe der Dateien und Recherche zum Thema Luftqualität in Innenräumen.
		\subsection{Achim Glaesmann}
		\subsection{Max-Rene Konieczka}
			Herr Konieczka war anfangs mit der Einarbeitung in Websockets beschäftigt um diese korrekt für die Übertragung der Daten zu verwenden. Zudem hat er Beihilfe bei der Integrierung von SerialPort.js geleistet, anschließend hat auch er sich wie Herr Knez und Herr Nazlier um die richtige Implementierung des Dashboards gekümmert, darunter auch Teile der Ampelindikation. 
		\subsection{Can Cihan Nazlier}
			Herr Nazlier hat sich zum einen um die Konfiguration der Programmierumgebung gekümmert. Dazu gehören die Erstellung eines GitHub-Repository und die Integrierung von Vue, einem JavaScript-Framework. Darüber hinaus hat er sich um die Integrierung einer Datenbank, die Implementierung des Zeichentools, anfangs in Form eines Prototypen, sowie einige Teile des Dashboards und der Ampelindikation gekümmert.
		
	\section{Luftqualität}%Lucas/Achim Friedrich
		Die Qualität der Luft setzt sich aus verschiedenen Faktoren zusammen. Für diese Projekt sind insbesondere die Faktoren Temperatur, Luftfeuchte, CO2 Gehalt und VOC (volatile organische Komponenten) wichtig, da wir mit den gegebenen Sensoren nur diese messen könne.
		\subsection{Luftfeuchte und Temperatur}
			Luftfeucht im allgemeinen bezeichnet die Menge an Wasserdampf die von der Umgebungsluft aufgenommen werden kann, bevor dieser kondensiert. Dabei unterscheidet man zwischen der absoluten, der maximalen und der relativen Luftfeuchte. Maximale Luftfeuchte bezeichnet hierbei den maximalen Wassergehalt in der Luft bevor das Wasser anfängt zu kondensieren. Die absolute Luftfeuchte gibt an wie viel Wasser sich derzeit in der Luft befindet und die relative Luftfeuchte gibt die Relation der beiden Größen in Prozent an. Die Luftfeuchte ist zudem stark von der Temperatur abhängig, dabei gilt: je höher die Temperatur der Luft desto größer die maximale Luftfeuchte und umgekehrt. Laut Inverter\cite{luftquali_inventer} ist für Wohn- und Arbeitsräume bei einer Temperatur von 20$^\circ$C eine Luftqualität von 40 - 60\% optimal. Bei zu geringer Luftfeuchte ($<$ 40\%) kann es u.A. zu Augen-, Haut-, und Schleimhautreizungen kommen. Bei Werten unter 23\% setzt Feuchtigkeitsverlust ein, der nicht über das Atmen kompensiert werden kann und es kann zu Stromschlägen bei Berührung mit Metall kommen. Zudem kann es zu Schäden an Bausubstanzen wie Holz u.ä. kommen. Bei zu hoher Luftfeuchte ($>$ 60\%) bildet sich schnell Schimmel welcher nicht nur die Bausubstanz schädigen kann sonder auch gesundheitliche Schäden nach sich ziehen kann. Überschreitet die Feuchtigkeit 80\% kann es zudem zur Vermehrung von Pilzen, Milben und anderen Parasiten kommen. Um dem Ganzen vorzubeugen, hilft es regelmäßig zu lüften.
			%TODO evt. einfluss auf corona		
		\subsection{CO2}
			Laut verschiedenen Quellen, u.A. dem Umweltbundesamt \cite{luftquali_bund_co2}\cite{luftquali_co2_corona} gilt CO2 als Leitparameter um zu bestimmen wie viele Menschen sich in einem Raum aufhalten, vorausgesetzt es befinden sich keine weiteren CO2-Quellen in diesem Raum. CO2 ist ein geruch- und farbloses Gas und ist mit einer Konzentration von 400ppm natürlicher Bestandteil der Umgebungsluft.
		\subsection{VOC}
			Die volatilen organischen Komponenten (VOC) setzten sich aus verschiedenen Stoffen unterschiedlicher Emission zusammen. Meist betrachtet man hier organische Emissionsquellen wie Lebewesen, Baumaterialien wie Holz oder andere chemische Verbindungen. Diese Stoffe sind jederzeit in der Luft enthalten und in größeren Mengen schädlich für den Menschen und andere Lebewesen. Da VOC viele Schadstoffe zusammenfasst ist es schwer daraus eine konkrete Aussage über die Gesundheitlichen folgen zu machen. Schäden können laut Inverter \cite{luftquali_inventer} von Geruchsbelästigung, Augen- und Atemwegsreizung  über akute Vergiftungen bis hin zur Schädigung des Nervensystems, der Verstärkung von Allergien und dem Auslösen von Krebs reichen. Das Umweltbundesamt \cite{luftquali_bund_voc} unterscheidet hierbei sehr flüchtige und schwer flüchtige organische Verbindungen. Die Summe der Konzentrationen aller VOC ergibt den TVOC-Wert (total volatile organic compounds). Als Richtwerte existieren laut einem Bericht des Umweltbundesamts \cite{luftquali_bund_rw} der sog. Richtwert I und der Richtwert II. Diese Richtwerte gelten jedoch nicht für TVOC als Gesamtes sonder sind für die meisten enthaltenen Stoff festgelegt. Dabei bestimmt der Richtwert eine Grenze für die gilt, dass bei der Unterschreitung des Wertes auch bei lebenslanger Aussetzung keine gesundheitlichen Schäden zu erwarten sind. Im Gegensatz dazu stellt der Richtwert II eine Grenze dar, bei deren Überschreitung eine akute Gesundheitsgefahr besteht und ein unverzüglicher Handlungsbedarf besteht. Zudem wurde generell festgelegt, das die Konzentration der TVOC bei langfristiger Aussetzung nicht über 1 - 3 mg/m3 (ca 150 - 500ppb) überschritten werden sollte.
	\section{Lösungsansatz} %detaillierte beschreibung der einzelnen Aufgaben, probleme und Lösungen
		%TODO different subsections wer was wie gelöst hat und welche Probleme aufgetreten sind, dabei angeben welche Standards/werkzeuge/equipment genutzt worden sind
		\subsection{SHT21}
		\subsection{SCD41}
		\subsection{CCS811}
			Der CCS811 \cite{ccs_datasheet}ist ein Sensor von ams, der den äquivalenten CO2 (eCO2) Gehalt und den Gehalt der totalen flüchtigen organischen Verbindungen (TVOC) in der Luft messen kann. Dabei kann eCO2 von 400ppm bis 8192ppm, TVOC von 0ppb bis 1187ppb gemessen werden und ein Messintervall von 250ms, 1s, 10s, 60s festgelegt werden. Die Pin-Beschreibungen kann man in Abbildung \ref{img:ccs_pintable} sehen. Wichtig sind hiervon die Pins:
			\begin{itemize}
				\item VDD: Anschluss an 3,3V als Versorgungsspannung (min 1,8V)
				\item nWAKE: Anschluss an GND (active low), damit der Sensor durchgehend aktiv ist
				\item SDA: Data Anschluss für I2C, wird mit einem SDA Pin des Zigbee-Boards verbunden
				\item SCL: Clock Anschluss für I2C, wird mit einem SCL Pin des Zigbee-Boards verbunden
				\item GND: Ist nicht in der Tabelle angegeben, muss aber mit GND auf dem Zigbee-Board verbunden werden
			\end{itemize}
			\begin{figure}[!h]
				\centering
				\includegraphics[scale=0.50]{images/ccs_pintable}
				\caption{Tabelle mit den Beschreibungen der Pins des CCS811}
				\label{img:ccs_pintable}
			\end{figure}
			In Abbildung \ref{label} ist das Zustandsdiagramm des CCS811 Sensors dargestellt. Zustände die nicht mit dem Sensor interagieren sind hier nicht dargestellt. Zu Beginn wird 2000 ms gewartet da der SCD41 Sensor entsprechende Zeit zum starten braucht. Die eigentliche Startzeit des CCS811 beträgt maximal nur 20ms. Der Zugriff auf den Sensor über den I2C-Bus spricht die Adresse 0x5A an, da der ADDR Pin nicht gesetzt ist. Im APP\_RESET\_CSS\_SW\_STATE wird mit 0xFF das SOFTWARE\_RESET\_REG angesprochen und der Befehl 0x11 0xE5 0x72 0x8A geschrieben. Dieser Befehl dient dazu einen versehentlichen Software Reset zu verhindern. Ist diese Sequenz geschrieben worden, befindet sich der Sensor im Boot mode. Zwischen den einzelnen I2C-Befehlen wird immer 1ms gewartet um sicherzugehen, das der Befehl richtig ausgeführt werden kann. Dies führt zwar zu einem erhöhten Zeitaufwand, ist jedoch unbedenklich, da der Messintervall 60 s beträgt und somit genügend Zeit zur Verfügung steht. Im nächsten Schritt wird das HW\_ID\_REG angesprochen und im darauf im folgenden Zustand auch ausgelesen. Hierbei ist wichtig, dass die HW\_ID 0x81 ist. Im APP\_CCS\_CHANGE\_TO\_APPSTATE\_STATE wird mit dem Befehl 0xF4 zurück in den Appstate gewechselt. Nun wird das MEAS\_MODE\_REG 0x01 angesprochen und der Befehl 0x30 geschrieben. Dieser Befehl setzt den Messintervall auf 60s, welcher den geringsten Stromverbrauch hat. Zum Testen der Applikation wurde hier ein kürzerer Intervall gewählt. Zudem werden keine Interrupts gesetzt die feuern würden wenn Daten vorhanden wären. Um zu überprüfen ob die Messung funktioniert, wird nun 60s gewartet und dann das STATUS\_REG 0x00 überprüft, ob Daten vorhanden sind. Ist dies der Fall, ist das 3. Bit gesetzt. Falls ein Fehler auf dem I2C-Bus oder dem Sensor aufgetreten ist, könnte man dies über das 0. Bit feststellen und im Register 0xE0 auslesen. Sind Daten zum abrufen bereit, werden die Sensoren SHT21 und SCD41 initialisiert. Dabei wird auch der Messtimer von 60s gestartet. Sind diese 60s abgelaufen, so wird das ALG\_RESULT\_DATA\_REG 0x02 angesprochen in dem die bereits berechneten Daten der Messung bereit liegen. Diese werden als 4 Byte ausgelesen, wobei die Bytes 0 und 1 den eCO2 Wert beinhalten und Byte 3 und 4 den TVOC Wert. Eine Umrechnung der Daten ist nicht nötig, da diese bereits der Sensor selbst umrechnet und somit im richtigen Format ausgelesen werden können.
			\begin{figure}[!h]
				\centering
				\includegraphics[scale=0.30]{images/ccs_zustandsdiagramm}
				\caption{Zustandsdiagramm des CCS811 Sensors, rechts: Initialisierung, links: Auslesen der Werte}
				\label{img:ccs_zustandsdiagramm}
			\end{figure}
				\subsubsection{Probleme bei der Programmierung des CCS811}
					Da sich der CCS811 in seiner Funktionsweise von den anderen beiden Sensoren unterscheidet, war es zu Anfang schwierig einen richtigen Ansatz zu bekommen. Vor allem das Wechseln in den Bootmodus war erst nach der Erläuterung in der Vorlesung klar und damit auch nachvollziehbarer. Zudem haben teilweise die Funkmodule nicht richtig Funktioniert, da entweder überhaupt nichts über die UART ausgegeben werden konnte oder die bei einem I2C-Befehl der Callback mit Error zurück gekommen ist. Nachdem wir den Code mehrmals auf Richtigkeit der Befehle und Ablauf überprüft haben, haben wir das ZigBee-Board ausgewechselt und das Messen hat ohne Probleme funktioniert. Was dabei der genaue Fehler war ist uns nicht bekannt. Zudem war die Funktion der Pins nWAKE und ADDR zu Anfang nicht klar. Der nWAKE Pin ist dafür da damit der Sensor aktiv ist und muss dafür auf low gezogen werden. Also haben wir diesen and GND angeschlossen und somit ist der Sensor durchgehend aktiv. Der ADDR Pin gibt an ob die I2C-Adresse des Sensors 0x5A oder 0x5B ist. Da der ADDR Pin nicht angeschlossen ist, ist die I2C-Adresse 0x5A.
				\subsubsection{Funktionsweise des CCS811}
					Der CCS811 Sensor ist ein Metalloxid Sensor, der mittels eines anorganischen Metalloxid-Halbleiters, welcher mit der Zielsubstanz (Hier CO2 und VOC) reagiert und dadurch seinen Widerstand ändert. Aus der Änderung des Widerstands kann dann die Konzentration der Zielsubstanzen ermittelt werden \cite{wiki_gassensor}. Laut dem Datenblatt des Sensors wurde hierfür die von ams entwickelte "micro-hotplate technologie" verwendet. Probleme bei diesem Verfahren ist das Aussondern der Zielsubstanz und das Verhindern der Beeinflussung durch andere Substanzen (andere Gase) oder Einflüsse (Luftfeuchte). Die Beeinflussung durch andere Substanzen kann durch die Wahl des Metalloxids eingeschränkt werden, andere Einflüsse können wenn überhaupt nur durch ständige Anpassung der Berechnung ausgeglichen werden. Um eine Substanz, hier z.B. CO2 zu messen, reagiert das Metalloxid mit dem Gas. CO2 ist dabei ein oxidierendes Gas, gibt also Sauerstoff an das Metalloxid ab und verringert dadurch die Leitfähigkeit des Halbleiters. In Abbildung \ref{img:metalloxid_sensor} kann man dazu einige Beispiele sehen.
					\begin{figure}[!h]
						\centering
						\includegraphics[scale=0.30]{images/metalloxid_sensor}
						\caption{Verschiedene Metalloxide und die Veränderung des Widerstands durch die Reaktion mit verschiedenen Gasen\cite{metalloxidsensor}}
						\label{img:metalloxid_sensor}
					\end{figure}
					%TODO wikipedia als quelle?!
			\subsection{Zeichentool}
				\subsubsection{Funktionsweise}
				Für das Zeichentool wurde zunächst ein Prototyp geschrieben, um zu testen inwiefern man Räume einzeichnen können soll. Nachdem dieser erstellt worden war, wurde auf diesem Prototyp aufgebaut und das eigentliche Zeichentool implementiert. Mit einem Doppelklick lassen sich Punkte auf die Leinwand platzieren, sobald ein zweiter Endpunkt hinzugefügt wurde, entsteht eine Linie zwischen diesen Punkten. Erst nachdem ein geschlossener Raum gezeichnet und ihm ein Name gegeben wurde, kann man diesen permanent speichern und anzeigen lassen. Wenn man den Button "Show Rooms" anklickt, wird jeder Raum angezeigt, welcher gespeichert wurde. In dieser Übersicht gibt es drei weitere Funktionen, es können Sensoren in die verschiedenen Räumen platziert werden, überflüssige Räume können wieder entfernt und es kann über den Info-Button eine Tabelle angezeigt werden lassen, welche die Zahlenwerte der Sensoren anzeigt. 
				\subsubsection{Probleme beim Zeichentool}
		 		Wenn ein Raum gezeichnet und nicht direkt abgespeichert wird, kann man die Eckpunkte des Raumes auswählen und dadurch weiterhin durch die Leinwand bewegen. Somit können Räume möglicherweise noch nachjustiert werden. Wenn man allerdings unbeabsichtigt die Linie auswählt, wird diese von den Punkten getrennt. Dies hat den Grund, dass die Linie dynamisch implementiert wurde um dem User eine Nachjustierung zu ermöglichen. Wäre die Linie statisch eingebunden worden, könnte man sie nach der Entstehung zwischen zwei Punkten in keinerlei Weise beeinflussen. Der Anwender kann diesen Fehler allerdings ganz einfach wieder beheben, indem einer der Punkte ausgewählt und bewegt wird.
			
			\subsection{Dashboard}
			\subsubsection{Funktionsweise}
			Das Dashboard ist hauptsächlich dazu da, die ankommenden Sensordaten visuell darzustellen. Es besteht aus 4 Liniendiagrammen, die die Werte von Temperatur, relativer Feuchtigkeit, CO2 und TVOC anhand eines Liniengraphen anzeigen. Der Anwender hat die Möglichkeit verschiedene Zeiten einzustellen, somit kann er die Daten der vergangenen letzten 6, 24 und 168 Stunden aufrufen.
			Wenn einer der Zeit-Buttons benutzt wird, kann man für die nächsten drei Sekunden keine weitere Eingabe tätigen und werden erst nach diesem Zeitraum wieder freigeschaltet. Es braucht nämlich 3 Sekunden, bis die Daten vom Backend im Frontend geladen werden. 
			\subsubsection{Aufgetretene Probleme}
			Zunächst war festgelegt, dass die JavaScript-Library D3.js verwendet wird um die graphische Darstellung der Sensordaten zu realisieren. Diese enthält Funktionen um verschiedenste Diagramme zu erstellen. Die Funktionen manipulieren HTML-Elemente, dadurch können z.B. einerseits deren Größe und Breite eingestellt oder andererseits können komplett neue HTML-Elemente hinzugefügt werden. Das Erstellen von vier verschiedenen Liniendiagrammen und einer Ampel war zunächst schnell abgeschlossen. Nach dieser Erstellung wurde ein Socket implementiert um zu überprüfen, ob die Sensordaten im Dashboard ankommen, was im Anschluss auch der Fall war. Allerdings ist hier ein Problem hervorgekommen.\newline
			Die Sensorwerte sollten als Y-Koordinate und die dazugehörige Zeit als X-Koordinate angezeigt werden. Zwar gibt es in D3.js eine eigens dafür integrierte scaleTime-Funktion um eine Zeitachse zu erstellen, aber durch die Zeiteinheit konnte nun kein Graph angezeigt werden. Dies hatte den Grund, dass zu diesem Zeitpunkt kein Zeitwert von der Datenbank übertragen wurde. Für dieses Problem konnte keine direkte Lösung hinsichtlich der Implementierung gefunden werden, daher wurde kurzfristig entschieden auf die Chart.js-Library umzusteigen. Diese bietet beispielsweise fertige Diagramme an, in welchen man lediglich personalisierte Werte hinzufügen kann.\newpage 
			
			\subsection{COM-Port \& Mockdaten}
			Die Verbindung zwischen den ZigBee-Modulen und dem Backend wurde mit der Serialport.js Library hergestellt. Dadurch lassen sich Daten über eine COM-Port Schnittstelle an den PC schicken. Zu diesem Zeitpunkt standen keine Sensordaten zur Verfügung daher wurden Mockdaten erstellt um die Sendung zu simulieren. Dies hat...
			\subsubsection{Problembehandlung}
			Kleine Problembehandlung wegen Mockdaten: 
			Zu Beginn wurden die Mockdaten in einem JSON-Format durch eine Python-Applikation erstellt um die Datenübertragung an die Datenbank testen zu können. Zwar hat dies funktioniert, doch wurde nach kurzer Zeit festgestellt, dass das nicht der beste Lösungsansatz war. Da die Daten von einem Sensor empfangen werden sollten, wurde entschieden ein C-Programm auf ein ZigBee-Modulen zu programmieren, welches lediglich einen String mit einer bestimmten Anzahl an Werten abschickt, um die Übertragung von Sensordaten zu simulieren. 
			
			\subsection{Installationsdatei}
			Alles bisherige wurde in Express gebündelt und in zwei PowerShell-Skripte unterteilt. Einmal wird das kompilierte Frontend mit Electron, und das kompilierte Backend in Express.js gestartet.\newline
			Es konnte keine EXE.-Datei erstellt werden, da die Nodeversion vom Serialport.js, was verwendet wurde um die Kommunikation mit den COM-Port Schnittstellen herzustellen, und die serverseitige Nodeversion verschieden und daher nicht kompatibel waren. (Electron war damit auch nicht kompatibel) 
			
	\section{Ausblick und Erweiterungsmöglichkeiten}
		\subsection{Genauere Bestimmung der Werte des CCS811}
			Wie bereits angesprochen ist der Sensor durch Einflüsse wie die Luftfeuchte beeinflussbar. Dies könnte man einschränken, indem man die gemessene Luftfeucht  der anderen Sensoren an den CCS811 überträgt und damit die Werte berichtigt. Selbiges gilt für die Temperatur. 
		
		

%----------------------------------------------------------------------------
% Bibliography
%----------------------------------------------------------------------------	
\printbibliography
\end{document}
